---
layout: documentation/document
title: Querying
description: Carbon LDP is a Linked Data Platform for building web apps that manage and link data within your enterprise and across the World Wide Web.
date: 2017-02-08 11:57:36
version: v1.0.x
---
<div class="documentation-steps ui fluid steps">
	<a class="step" href="../files">
		<i class="arrow left icon"></i>
		<div class="content">
			<div class="title">Previous</div>
			<div class="description">Files</div>
		</div>
	</a>
	<div class="active step">
		<!--<i class="payment icon"></i>-->
		<div class="content">
			<div class="title">Querying</div>
		</div>
	</div>
	<a class="step" href="../authentication">
		<i class="arrow right icon"></i>
		<div class="content">
			<div class="title">Next</div>
			<div class="description">Authentication</div>
		</div>
	</a>
</div>

<div class="ui mobile only grid">
	<div class="row">
		<staticContentMenu content="mainContent"></staticContentMenu>
	</div>
</div>


<!-- START: Introduction -->
<section class="mainContent-section">
	<h2 class="hidden">Introduction</h2>

	<p>Carbon LDP resources can be queried using <a href="https://www.w3.org/TR/sparql11-query/">SPARQL</a>, a W3C standard query language.</p>

	<p>
		SPARQL has <em>some</em> similarities to SQL, the Structured Query Language for relational databases, but there are also fundamental differences.
		The main difference with SPARQL is that, instead of filtering results to get a desired outcome (like in SQL),
		you apply <strong>patterns</strong> that are tested over the data to retrieve results. These patterns are given along with <strong>query form</strong> to define the shape of the results.
	</p>
	<p>
		There are four different query forms:
	</p>
	<ul>
		<li><strong>SELECT</strong></li>
		<ul>Returns the matched data in a table-like structure</ul>
		<li><strong>ASK</strong></li>
		<ul>Returns <code>true</code> or <code>false</code> indicating whether data matched the pattern(s)</ul>
		<li><strong>CONSTRUCT</strong></li>
		<ul>Restructures the matched data into a graph described by a specified template</ul>
		<li><strong>DESCRIBE</strong></li>
		<ul>Returns a description of how the data is internally stored</ul>
	</ul>

	<p>
		A <strong>pattern</strong> is defined by using three elements:
	</p>
	<ol>
		<li><strong>Resource</strong>: any document, fragment or named fragment referenced by a URI</li>
		<li><strong>Property</strong>: the name or URI of a property of the resource</li>
		<li><strong>Value</strong>: the value of the property</li>
	</ol>
	<p>
		For example, if we wanted to match a document that represented a project, which has the property <code>name</code>
		with the value <code>"Project X"</code>, we could use the pattern:
	</p>
	<ol>
		<li><strong>Resource</strong>: <code>projects/project-01/</code> (the project's ID/URI)</li>
		<li><strong>Property</strong>: <code>name</code></li>
		<li><strong>Value</strong>: <code>"Project X"</code></li>
	</ol>

	<p>
		This example pattern fully defines all of its elements. Each pattern element has the exact value we're trying to match. But querying
		involves retrieving more data than we already have, so each pattern element can also be a variable.
	</p>
	<p>
		A variable acts like a wildcard, matching any values the pattern element can have. But unlike wildcards, a variable stores any value
		it matches (you can think of them kind of like the columns requested on SQL queries).
	</p>
	<p>
		<strong>E.g</strong>: To query the name of a project you would only need the project's URI (resource) and the name (property).
		The value would be represented by a variable in which you will obtain the data you queried for.
	</p>
	<p>
		Now, you may be asking: "what about modifying a document like <code>UPDATE</code> or <code>ALTER</code>?".
		For those cases the platform also supports <a href="https://www.w3.org/TR/sparql11-update/">SPARQL UPDATE</a>, another W3C standard,
		that lets you add or delete any data (really, ANY data). Because of this, SPARQL UPDATE is currently only available to the System Administrator,
		though we intend to broaden that scope in a subsequent release.
	</p>
</section>
<!-- END: Introduction -->


<!-- START: SPARQL Query Builder -->
<section class="mainContent-section">
	<h2>SPARQL Query Builder</h2>

	<p>
		The SDK integrates our own query builder called <a href="https://github.com/CarbonLDP/sparqler">SPARQLER</a> (SPARQL
		query buildER) which offers a <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a> to help you construct queries and prevent errors by malformed patterns.
	</p>

	<div class="ui info icon message">
		<i class="info circle icon"></i>
		<div class="content">
			<p>
				Currently, we only support <code>SELECT</code> queries with SPARQLER.
				<br/>
				We intend to extend the builder to cover more features in a subsequent release.
			</p>
		</div>
	</div>

	<p>
		To create a query you must call the method <code>sparql( documentURI:string )</code> of the <code>documents</code>
		service along with the document URI to query against.
	</p>
	<p>
		If you already have a <code>PersistedDocument</code> you can also call its <code>sparql()</code> method, to query directly on it.
	</p>

	<tabs>
		<tab title="TypeScript">
			<pre><code class="typescript">
				import * as PersistedDocument from "carbonldp/PersistedDocument";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "resource-end-point/" )
					// ... query construction
					;


				let persistedDocument:PersistedDocument.Class;
				// ... get the persistedDocument
				persistedDocument.sparql()
					// ... query construction
					;
			</code></pre>
		</tab>
		<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "resource-end-point/" )
					// ... query construction
					;


				let persistedDocument;
				// ... get the persistedDocument
				persistedDocument.sparql()
					// ... query construction
					;
				</code></pre>
		</tab>
		<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "resource-end-point/" )
					// ... query construction
					;


				var persistedDocument;
				// ... get the persistedDocument
				persistedDocument.sparql()
					// ... query construction
					;
			</code></pre>
		</tab>
	</tabs>

	<section class="mainContent-section">
		<h2>SELECT Query</h2>

		<section class="mainContent-subSection">
			<h3>General structure</h3>
			<p>
				SPARQL SELECT queries have the following structure and order:
			</p>
			<ol>
				<li>Select what data to include in the response:</li>
				<ul>
					<li><code>.select( ... variables )</code> or <code>.selectAll()</code></li>
				</ul>
				<li>Specify the patterns to match:</li>
				<ul>
					<li><code>.where( ... patterns )</code></li>
				</ul>
				<li>Add optional solution modifiers:</li>
				<ul>
					<li><code>.groupBy( ... )</code></li>
					<li><code>.having( ... )</code></li>
					<li><code>.orderBy( ... )</code></li>
					<li><code>.limit( ... )</code></li>
					<li><code>.offset( ... )</code></li>
				</ul>
				<li>And finally execute the query:</li>
				<ul>
					<li><code>.execute()</code> or <code>.executeRaw()</code></li>
				</ul>
			</ol>
		</section>

		<section class="mainContent-subSection">
			<h3>Data Selection</h3>
			<p>
				We can specify which variables to be included by using one of two methods:
			</p>
			<ul class="list">
				<li><code>.select( ...variables:string[] )</code>. Specify which variables used in the pattern(s) will be returned with the query result</li>
				<li><code>.selectAll()</code>. Indicate that all variables used in the pattern(s) will be included in the result</li>
			</ul>

			<p>
				In the case of the pattern to match, it's a little different since you need to provide a function where you can
				construct the pattern:
			</p>
			<ul>
				<li><code>.where( patternFunction:( builder:PatternBuilder ) => GraphPattern )</code>. A single pattern to match</li>
				<li><code>.where( patternFunction:( builder:PatternBuilder ) => GraphPattern[] )</code>. Multiple patterns to match</li>
			</ul>
			<p>
				As you can see, the <code>patternFunction</code> receives a <code>SPARQL/PatternBuilder</code>
				object which contains helper properties and functions to construct the patterns you need.
			</p>

			<h4>Example</h4>
			<p>
				Assuming we had the following object stored:
			</p>
			<pre><code class="javascript">
				// Representation of the stored object
				{
					// Document URI
					"@id": "http://localhost:8083/projects/project-01/",

					// Properties
				    "name": "Project X",
					"startDate": "2017/02/19"

					// ...
				}
			</code></pre>
			<p>
				The following query would retrieve the values of the <code>name</code> and
				<code>startDate</code> property:
			</p>
			<tabs>
				<tab title="TypeScript">
					<pre><code class="typescript">
						import { PatternBuilder } from "sparqler/PatternBuilder";

						let carbon:Carbon;

						// ... initialize your Carbon object

						// ... authenticate if needed

						carbon.documents.sparql( "projects/project-01/" )
							.select( "projectName", "projectStart" )
							.where( ( _:PatternBuilder ) => {
								return _.resource( "projects/project-01/" )
									.has( "name", _.var( "projectName" ) )
									.and( "startDate", _.var( "projectStart" ) );
							} )
							;
					</code></pre>
				</tab>
				<tab title="JavaScript ES2015">
					<pre><code class="javascript">
						let carbon;

						// ... initialize your Carbon object

						// ... authenticate if needed

						carbon.documents.sparql( "projects/project-01/" )
							.select( "projectName", "projectStart" )
							.where( _ => {
								return _.resource( "projects/project-01/" )
									.has( "name", _.var( "projectName" ) )
									.and( "startDate", _.var( "projectStart" ) );
							} )
							;
					</code></pre>
				</tab>
				<tab title="JavaScript ES5">
					<pre><code class="javascript">
						var carbon;

						// ... initialize your Carbon object

						// ... authenticate if needed

						carbon.documents.sparql( "projects/project-01/" )
							.select( "projectName", "projectStart" )
							.where( function( _ ) {
								return _.resource( "projects/project-01/" )
									.has( "name", _.var( "projectName" ) )
									.and( "startDate", _.var( "projectStart" ) );
							} )
							;
					</code></pre>
				</tab>
			</tabs>
			<p>
				The query can be translated to:
			</p>
			<ul>
				<li>Search for a resource that has the id <code>projects/project-01/</code></li>
				<li>This resource must have a property <code>name</code> with any value(s)</li>
				<ul>
					<li>Store those values in the <em>projectName</em> variable</li>
				</ul>
				<li>The resource must also have the property <code>startDate</code> with any value(s)</li>
				<ul>
					<li>Store those values in the <em>projectStart</em> variable</li>
				</ul>
				<li>Return me the values stored in the variables <em>projectName</em> and <em>projectStart</em></li>
			</ul>
			<p>
				In this example we are using the <code>var( variableName )</code> function of the helper object <code>_</code> to declare two variables:
			</p>
			<ul>
				<li><code>projectName</code></li>
				<li><code>projectStart</code></li>
			</ul>
			<p>
				These variables must appear in the pattern to match so they can be assigned values.
			</p>
			<p>
				In the <code>.where()</code> method, we use the <code>PatternBuilder</code> to first indicate we are targeting a resource
				with the URI: <code>projects/project-01/</code>, and as the URI is relative, it will be automatically resolved to
				<code>http://localhost:8083/projects/project-01/</code> (assuming the platform's host is <code>http://localhost:8083/</code>).
			</p>
			<p>
				From this resource we call the <code>has()</code> method, to indicate that the resource must have a property called <code>name</code>,
				with value(s) bound to the variable <code>projectName</code>.
			</p>
			<p>
				Next we call the <code>and()</code> method, stating that it also needs to have a property <code>startDate</code>,
				with value(s) bound to the variable <code>projectStart</code>.
			</p>

			<h4>Example</h4>
			<p>
				To retrieve the name and start date from <em>all</em> available projects, we need to consider the following:
			</p>
			<ul class="list">
				<li>The end-point of the query must be the container of the projects: <code>projects/</code></li>
				<li>The children of the container are under the property: <code>http://www.w3.org/ns/ldp#contains</code></li>
				<li>We need to bind every child document (project) and ask for its name and start date, as in the previous example</li>
			</ul>

			<tabs>
				<tab title="TypeScript">
			<pre><code class="typescript">
				import { PatternBuilder } from "sparqler/PatternBuilder";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( ( _:PatternBuilder ) => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					;
			</code></pre>
				</tab>
				<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( _ => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					;
				</code></pre>
				</tab>
				<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( function( _ ) {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					;
			</code></pre>
				</tab>
			</tabs>

			<p>
				As we can see, the major difference is that we return of an array of patterns. The first pattern matches the child
				documents from the <code>projects/</code> container and binds them to the <code>everyProject</code> variable.
				With this variable we can then ask for the name and start date of every corresponding project.
			</p>

		</section>

		<section class="mainContent-subSection">
			<h3>Solution modifiers</h3>
			<p>
				This methods are optional and they let you modify the solutions returned:
			</p>
			<ul>
				<li>
					<code>.groupBy( rawCondition:string )</code>. Group the data in order to calculate aggregated values for a solution
				</li>
				<li>
					<code>.having( rawCondition:string )</code>. Filter grouped solution sets
				</li>
				<li>
					<code>.orderBy( rawCondition:string )</code>. Establish the order of the a sequence of solutions
				</li>
				<li>
					<code>.limit( limit:string )</code>. Restrict the number of solutions returned
				</li>
				<li>
					<code>.offset( offset:string )</code>. Control where the solutions returned start from the overall set of them
				</li>
			</ul>

			<h4>Example</h4>
			<p>
				Considering the same case of retrieving the name and start date of every project, but with the solutions modifiers
				we'll retrieve the last 10 projects that have been started.
			</p>
			<tabs>
				<tab title="TypeScript">
			<pre><code class="typescript">
				import { PatternBuilder } from "sparqler/PatternBuilder";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( ( _:PatternBuilder ) => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					;
			</code></pre>
				</tab>
				<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( _ => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					;
				</code></pre>
				</tab>
				<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( function( _ ) {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					;
			</code></pre>
				</tab>
			</tabs>

			<p>
				We use the <code>.orderBy()</code> method to specify a descending order for the results, based on the project start date,
				and we use the <code>.limit()</code> method to limit the returned solutions to 10. Notice that it is not required to use a
				question mark with the variables declared with the <code>_.var()</code> helper. However, the solution modifiers like
				<code>.orderBy()</code> use RAW strings, so we have to use a question mark to specify the variable (e.g. <code>?projectStart.</code>)
			</p>
		</section>

		<section class="mainContent-subSection">
			<h3>Query execution</h3>

			<p>
				Until now we've only been building the query and nothing more, but the important thing is to execute it and use the
				solutions returned.
			</p>
			<p>
				For a SELECT query we have two methods:
			</p>
			<ul>
				<li>
					<code>.execute()</code>. Return a promise with the parsed result as described in: <code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-SPARQL-SELECTResults-Class">Carbon.SPARQL.SELECTResults.Class</a></code>
				</li>
				<li>
					<code>.executeRaw()</code>. Return a promise with the JSON results as described in: <code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-SPARQL-RawResults-Class">Carbon.SPARQL.RawResults.Class</a></code>
				</li>
			</ul>

			<h4>Example</h4>
			<p>
				Following the previous examples, we'll execute the query we have been building and then return an array of projects with
				the data obtained.
			</p>
			<tabs>
				<tab title="TypeScript">
			<pre><code class="typescript">
				import * as SPARQL from "carbonldp/SPARQL";
				import * as HTTP from "carbonldp/HTTP";
				import { PatternBuilder } from "sparqler/PatternBuilder";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( ( _:PatternBuilder ) => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					.execute()
					.then( ( [ result, response ]:[ SPARQL.SELECTResults.Class, HTTP.Response.Class ] ) => {
						return result
							.bindings
							.map( binding => ( {
								name: binding[ "projectName" ],
								startDate: binding[ "projectStart" ],
							} )
							;
					} )
					;
			</code></pre>
				</tab>
				<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( _ => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					.execute()
					.then( ( [ result, response ] ) => {
						return result
							.bindings
							.map( binding => ( {
								name: binding[ "projectName" ],
								startDate: binding[ "projectStart" ],
							} )
							;
					} )
					;
				</code></pre>
				</tab>
				<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( function( _ ) {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					.execute()
					.then( function( [ result, response ] ) {
						return result
							.bindings
							.map( function( binding ) {
								return {
									name: binding[ "projectName" ],
									startDate: binding[ "projectStart" ],
								};
							} )
							;
					} )
					;
			</code></pre>
				</tab>
			</tabs>

			<p>
				The result object contains a <code>bindings</code> property with an array containing the solutions of
				the query. Every element in this array is an object that has the variable names as keys and each variable's
				bound value.
			</p>

		</section>
	</section>


	<section class="mainContent-subSection">
		<h3>Query configuration</h3>
		<p>
			With the SPARQLER integration, every query has access to the following default information:
		</p>
		<ul>
			<li><strong>Prefixes</strong>. Every prefix in the global schema</li>
			<li><strong>Vocabulary</strong>. The platform instance vocabulary to resolve property names, as in the <a href="http://carbonldp.com/documentation/javascript-sdk/object-schema/#vocabularies">Object Schema</a></li>
			<li><strong>Base</strong>. The URI where your platform instance lives, against which relative URIs will be resolved.</li>
		</ul>

		<p>
			To configure the builder to your own preferences you can use the following methods:
		</p>
		<ul class="list">
			<li><code>vocab( uri:string )</code>: Set or replace the existing vocabulary</li>
			<li><code>base( uri:string )</code>: Replace the base URI</li>
			<li><code>prefix( name:string, uri:string )</code>: Add or replace existing prefixes in the SPARQLER</li>
		</ul>

		<h4>Example</h4>
		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "resource-end-point/" )
					// Sets a well defined vocabulary
					.vocab( "https://schema.org/" )

					// Sets the base to the document end point
					.base( "resource-end-point/" )

					// Adds new prefixes that may be used in the document
					.prefix( "bib": "https://bib.schema.org/" )
					.prefix( "auto": "https://auto.schema.org/" )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "resource-end-point/" )
					// Sets a well defined vocabulary
					.vocab( "https://schema.org/" )

					// Sets the base to the document end point
					.base( "resource-end-point/" )

					// Adds new prefixes that may be used in the document
					.prefix( "bib": "https://bib.schema.org/" )
					.prefix( "auto": "https://auto.schema.org/" )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.sparql( "resource-end-point/" )
					// Sets a well defined vocabulary
					.vocab( "https://schema.org/" )

					// Sets the base to the document end point
					.base( "resource-end-point/" )

					// Adds new prefixes that may be used in the document
					.prefix( "bib": "https://bib.schema.org/" )
					.prefix( "auto": "https://auto.schema.org/" )
					;
			</code></pre>
			</tab>
		</tabs>
	</section>
</section>
<!-- END: SPARQL Query Builder -->


<!-- START: SPARQL Services -->
<section class="mainContent-section">

	<h2 class="hidden">SPARQL Services</h2>

	<p>
		As an alternative to the way of building queries with the SPARQL Query Builder (as we've shown so far), the SDK also
		supports the use of standard SPARQL queries passed as strings. You might prefer this approach when if you are comfortable
		writing standard SPARQL queries or in order to leverage features that are not yet available in the SPARQL Query Builder.</p>

	<p>Standard SPARQL queries can be written and tested using the SPARQL Client in the Carbon LDP Workbench. They can then be copied
		and pasted directly into JavaScript strings as-is. A notable difference is that relative property names cannot be used as they
		can in the SPARQL Query Builder, so standard SPARQL queries might be more verbose with fully qualified URIs in some cases.</p>

	<p>
		The methods to execute a standard SPARQL query (given as a string), are also called from the <code>Documents</code> service.
	</p>

	<section class="mainContent-subSection">
		<h3>SELECT Queries</h3>
		<ul>
			<li><code>executeSELECTQuery( documentURI:string, selectQuery: string )</code></li>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeRawSELECTQuery">executeRawSELECTQuery</a>( documentURI:string, selectQuery: string )</code></li>
		</ul>
		<p>
			These methods are the equivalent to the <code>.execute()</code> and <code>.executeRaw()</code> in a SELECT
			query with the Query Builder.
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as SPARQL from "carbonldp/SPARQL";
				import * as HTTP from "carbonldp/HTTP";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeSELECTQuery( "projects/", `
					BASE &lt;http://localhost:8083/>
					PREFIX ldp: &lt;http://www.w3.org/ns/ldp#>
					SELECT ?projectName ?projectStart
					WHERE {
						&lt;projects/> ldp:contains ?everyProject .
					    ?everyProject &lt;vocabulary/#name> ?projectName ;
					                  &lt;vocabulary/#startDate> ?projectStart
					}
					ORDER BY DESC( ?projectStart )
					LIMIT 10
				` )
					.then( ( [ result, response ]:[ SPARQL.SELECTResults.Class, HTTP.Response.Class ] ) => {
						return result
							.bindings
							.map( binding => ( {
								name: binding[ "projectName" ],
								startDate: binding[ "projectStart" ],
							} )
							;
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeSELECTQuery( "projects/", `
					BASE &lt;http://localhost:8083/>
					PREFIX ldp: &lt;http://www.w3.org/ns/ldp#>
					SELECT ?projectName ?projectStart
					WHERE {
						&lt;projects/> ldp:contains ?everyProject .
					    ?everyProject &lt;vocabulary/#name> ?projectName ;
					                  &lt;vocabulary/#startDate> ?projectStart
					}
					ORDER BY DESC( ?projectStart )
					LIMIT 10
				` )
					.then( ( [ result, response ] ) => {
						return result
							.bindings
							.map( binding => ( {
								name: binding[ "projectName" ],
								startDate: binding[ "projectStart" ],
							} )
							;
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeSELECTQuery( "projects/", "" +
					"BASE &lt;http://localhost:8083/>" +
					"PREFIX ldp: &lt;http://www.w3.org/ns/ldp#>" +
					"SELECT ?projectName ?projectStart" +
					"WHERE {" +
					"   &lt;projects/> ldp:contains ?everyProject ." +
					"   ?everyProject &lt;vocabulary/#name> ?projectName ;" +
					"                 &lt;vocabulary/#startDate> ?projectStart" +
					"}" +
					"ORDER BY DESC( ?projectStart )" +
					"LIMIT 10"
				)
					.then( function( [ result, response ] ) {
						return result
							.bindings
							.map( function( binding ) {
								return {
									name: binding[ "projectName" ],
									startDate: binding[ "projectStart" ],
								};
							} )
							;
					} )
					;
			</code></pre>
			</tab>
		</tabs>

	</section>

	<section class="mainContent-subSection">
		<h3>ASK Queries</h3>

		A standard SPARQL ASK query can be given as string and executed with one of the following:

		<ul>
			<li><code>executeASKQuery( documentURI:string, askQuery: string )</code></li>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeRawASKQuery">executeRawASKQuery</a>( documentURI:string, askQuery: string )</code></li>
		</ul>

		<p>
			The fist option returns a simple response with only the resulting boolean of the ASK query (e.g. <code>true</code> or <code>false</code>).
			The second one will return a JSON object as described in the <a href="https://www.w3.org/TR/2013/REC-sparql11-results-json-20130321/#ask-result-form">API Reference</a>:
			<code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-SPARQL-RawResults-Class">Carbon.SPARQL.RawResults.Class</a></code>
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeASKQuery( "projects/project-01/", `
					BASE        &lt;http://localhost:8083/>
					ASK {
					    &lt;projects/project-01/> &lt;vocabulary/#name> "Project X" ;
											   &lt;vocabulary/#startDate> "2017/02/19"
					}
				` )
					.then( ( [ result, response ]:[ boolean, HTTP.Response.Class ] ) => {
						// result will be `true`
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeASKQuery( "projects/project-01/", `
					BASE        &lt;http://localhost:8083/>
					ASK {
					    &lt;projects/project-01/> &lt;vocabulary/#name> "Project X" ;
											   &lt;vocabulary/#startDate> "2017/02/19"
					}
				` )
					.then( ( [ result, response ] ) => {
						// result will be `true`
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeASKQuery( "projects/project-01/", "" +
					"BASE        &lt;http://localhost:8083/>" +
					"ASK {" +
					"    &lt;projects/project-01/> &lt;vocabulary/#name> \"Project X\" ;" +
					"                           &lt;vocabulary/#startDate> \"2017/02/19\"" +
					"}" +
				)
					.then( function( [ result, response ] ) {
						// result will be `true`
					} )
					;
			</code></pre>
			</tab>
		</tabs>
	</section>

	<section class="mainContent-subSection">
		<h3>CONSTRUCT Queries</h3>
		<ul>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeRawCONSTRUCTQuery">executeRawCONSTRUCTQuery</a>( documentURI:string, constructQuery:string )</code></li>
		</ul>

		<p>
			When using the CONSTRUCT query, the server will respond with a raw string in the JSON-LD format, so you will have to process and parse it to your needs.
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeRawCONSTRUCTQuery( "projects/project-01/", `
					BASE        &lt;http://localhost:8083/>
					PREFIX schema:  &lt;https://schema.org/>
					CONSTRUCT   {
						&lt;projects/project-01/> schema:name ?projectName ;
											   schema:startDate ?projectStart
					}
					WHERE {
					    &lt;projects/project-01/> &lt;vocabulary/#name> ?projectName ;
											   &lt;vocabulary/#startDate> ?projectStart
					}
				` )
					.then( ( [ result, response ]:[ string, HTTP.Response.Class ] ) => {
						// ... process the result JSON-LD string
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeRawCONSTRUCTQuery( "projects/project-01/", `
					BASE        &lt;http://localhost:8083/>
					PREFIX schema:  &lt;https://schema.org/>
					CONSTRUCT   {
						&lt;projects/project-01/> schema:name ?projectName ;
											   schema:startDate ?projectStart
					}
					WHERE {
					    &lt;projects/project-01/> &lt;vocabulary/#name> ?projectName ;
											   &lt;vocabulary/#startDate> ?projectStart
					}
				` )
					.then( ( [ result, response ] ) => {
						// ... process the result JSON-LD string
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeRawCONSTRUCTQuery( "projects/project-01/", "" +
					"BASE        &lt;http://localhost:8083/>" +
					"PREFIX schema:  &lt;https://schema.org/>" +
					"CONSTRUCT   {" +
					"	&lt;projects/project-01/> schema:name ?projectName ;" +
					"                          schema:startDate ?projectStart" +
					"}" +
					"WHERE {" +
					"    &lt;projects/project-01/> &lt;vocabulary/#name> ?projectName ;" +
					"                           &lt;vocabulary/#startDate> ?projectStart" +
					"}"
				)
					.then( function( [ result, response ] ) {
						// ... process the result JSON-LD string
					} )
					;
			</code></pre>
			</tab>
		</tabs>

		<p>
			In this example we create an Document with only the name and start date of the project, but the difference
			is that we rename the properties to a well defined the vocabulary: <code>https://schema.org/</code>:
		</p>
		<pre><code class="javascript">
			// Representation of the string returned
			{
				"id": "http://localhost:8083/projects/project-01/",

				// Properties
				"https://schema.org/name": "Project X",
				"https://schema.org/startDate": "2017/02/19"
			}
		</code></pre>
	</section>

	<section class="mainContent-subSection">
		<h3>DESCRIBE Queries</h3>
		<ul>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeRawDESCRIBEQuery">executeRawDESCRIBEQuery</a>( documentURI:string, describeQuery: string )</code></li>
		</ul>

		<p>
			When using the DESCRIBE query, the server will respond with a raw string in the JSON-LD format, so you will have to process and parse it to your needs.
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeRawDESCRIBEQuery( "projects/project-01/", `
					BASE     &lt;http://localhost:8083/>
					DESCRIBE &lt;projects/project-01/>
				` )
					.then( ( [ result, response ]:[ string, HTTP.Response.Class ] ) => {
						// ... process the result JSON-LD string
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeRawDESCRIBEQuery( "projects/project-01/", `
					BASE     &lt;http://localhost:8083/>
					DESCRIBE &lt;projects/project-01/>
				` )
					.then( ( [ result, response ] ) => {
						// ... process the result JSON-LD string
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeRawDESCRIBEQuery( "projects/project-01/", "" +
					"BASE     &lt;http://localhost:8083/>" +
					"DESCRIBE &lt;projects/project-01/>"
				)
					.then( function( [ result, response ] ) {
						// ... process the result JSON-LD string
					} )
					;
			</code></pre>
			</tab>
		</tabs>
	</section>

	<section class="mainContent-subSection">
		<h3>UPDATE</h3>
		<ul>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeUPDATE">executeUPDATE</a>( documentURI:string, update: string )</code></li>
		</ul>

		<p>
			A SPARQL UPDATE doesn't return any results data, thus it's not exactly a query and there's only one method in the SDK for executing the UPDATE.
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeUPDATE( "projects/project-01/", `
					BASE     &lt;http://localhost:8083/>
					DELETE {
						&lt;projects/project-01/> &lt;vocabulary/#name> "Project X"
					}
					INSERT {
						&lt;projects/project-01/> &lt;vocabulary/#name> "My new awesome name"
					}
					WHERE {
						&lt;projects/project-01/> &lt;vocabulary/#name> "Project X"
					}
				` )
					.then( ( response:HTTP.Response.Class ) => {
						// ... Update finished
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeUPDATE( "projects/project-01/", `
					BASE     &lt;http://localhost:8083/>
					DELETE {
						&lt;projects/project-01/> &lt;vocabulary/#name> "Project X"
					}
					INSERT {
						&lt;projects/project-01/> &lt;vocabulary/#name> "My new awesome name"
					}
					WHERE {
						&lt;projects/project-01/> &lt;vocabulary/#name> "Project X"
					}
				` )
					.then( response  => {
						// ... Update finished
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.executeUPDATE( "projects/project-01/", "" +
					"BASE     &lt;http://localhost:8083/>" +
					"DELETE {" +
					"	&lt;projects/project-01/> &lt;vocabulary/#name> \"Project X\"" +
					"}" +
					"INSERT {" +
					"	&lt;projects/project-01/> &lt;vocabulary/#name> \"My new awesome name\"" +
					"}" +
					"WHERE {" +
					"	&lt;projects/project-01/> &lt;vocabulary/#name> \"Project X\"" +
					"}"
				)
					.then( function( response ) {
						// ... Update finished
					} )
					;
			</code></pre>
			</tab>
		</tabs>
	</section>

</section>
<!-- END: SPARQL Services -->


<!-- START: Using the documents service -->
<section class="mainContent-section">
	<h2>Using the documents service</h2>

	<p>
		Another powerful way of creating queries is by using the <code>documents</code> service, particularly the <code>documents.get</code> method of such service.
		Up until now, we have been using this method to retrieve the content of a desired document, see below:
	</p>

	<h4>Example</h4>
	<p>Let's assume we have the following objects stored in our platform as children of <code>http://localhost:8083/clients/</code>:</p>
	<pre><code class="typescript">
				[
					{
						// Document URI
						"@id": "http://localhost:8083/clients/rpa/",
						// Types of the document
						"@types":[ "http://localhost:8083/vocabulary/#Client" ]

						// Properties
						name: "Royal Psychology Association",
						countryOfOrigin: "France",
						foundationYear: 1990,
						numberOfEmployees: 150,
					},
					{
						// Document URI
						"@id": "http://localhost:8083/clients/peoplestruck/",
						// Types of the document
						"@types":[ "http://localhost:8083/vocabulary/#Client" ]

						// Properties
						name: "Peoplestruck",
						countryOfOrigin: "Germany",
						foundationYear: 1945,
						numberOfEmployees: 25000,
					},
					{
						// Document URI
						"@id": "http://localhost:8083/clients/rivi/",
						// Types of the document
						"@types":[ "http://localhost:8083/vocabulary/#Client" ]

						// Properties
						name: "Remote Island Vehicular Institute",
						countryOfOrigin: "United States",
						foundationYear: 2001,
						numberOfEmployees: 100,
					}
				];
	</code></pre>
	<p>With this in mind, let's use the <code>documents.get</code> to normally retrieve a document.</p>


	<!-- START: Getting a document -->
	<section class="mainContent-section">
		<h3>Getting a document</h3>

		<p>
			To retrieve a <i>document containing all of its properties</i>, we use the <code>documents.get</code> method.<br>
			For example purposes, let's retrieve the <code>http://localhost:8083/clients/rivi/</code> document, like this:
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";
				import * as PersistedDocument from "carbonldp/PersistedDocument";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.get &lt;Client>( "clients/rivi/" )
				.then( ( [ client, response ]:[ Client & PersistedDocument.Class, HTTP.Response.Class ] ) => {

					console.log( client );
					// countryOfOrigin:"United States"
					// created: Wed Nov 15 2017 19:05:21 GMT-0600 (CST) {}
					// foundationYear: 2001
					// hasMemberRelation: {_id: "http://www.w3.org/ns/ldp#member", _resolved: false, isResolved: ƒ, resolve: ƒ}
					// insertedContentRelation: {_id: "http://www.w3.org/ns/ldp#MemberSubject", _resolved: false, isResolved: ƒ, resolve: ƒ}
					// membershipResource: {name: "Remote Island Vehicular Institute", countryOfOrigin: "United States", foundationYear: 2001, numberOfEmployees: 100, hasMemberRelation: {…}, …}
					// modified: Wed Nov 15 2017 19:05:21 GMT-0600 (CST) {}
					// name: "Remote Island Vehicular Institute"
					// numberOfEmployees: 100
					// Other inherited properties ...

				} );
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.get( "clients/rivi/" ).then( ( [ client, response ] ) => {

						console.log( client );
						// countryOfOrigin:"United States"
						// created: Wed Nov 15 2017 19:05:21 GMT-0600 (CST) {}
						// foundationYear: 2001
						// hasMemberRelation: {_id: "http://www.w3.org/ns/ldp#member", _resolved: false, isResolved: ƒ, resolve: ƒ}
						// insertedContentRelation: {_id: "http://www.w3.org/ns/ldp#MemberSubject", _resolved: false, isResolved: ƒ, resolve: ƒ}
						// membershipResource: {name: "Remote Island Vehicular Institute", countryOfOrigin: "United States", foundationYear: 2001, numberOfEmployees: 100, hasMemberRelation: {…}, …}
						// modified: Wed Nov 15 2017 19:05:21 GMT-0600 (CST) {}
						// name: "Remote Island Vehicular Institute"
						// numberOfEmployees: 100
						// Other inherited properties ...

					} );
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.get( "clients/rivi/" ).then( function ( result ) { {

						var client = result[ 0 ];
						var response = result[ 1 ];

						console.log( client );
						// countryOfOrigin:"United States"
						// created: Wed Nov 15 2017 19:05:21 GMT-0600 (CST) {}
						// foundationYear: 2001
						// hasMemberRelation: {_id: "http://www.w3.org/ns/ldp#member", _resolved: false, isResolved: ƒ, resolve: ƒ}
						// insertedContentRelation: {_id: "http://www.w3.org/ns/ldp#MemberSubject", _resolved: false, isResolved: ƒ, resolve: ƒ}
						// membershipResource: {name: "Remote Island Vehicular Institute", countryOfOrigin: "United States", foundationYear: 2001, numberOfEmployees: 100, hasMemberRelation: {…}, …}
						// modified: Wed Nov 15 2017 19:05:21 GMT-0600 (CST) {}
						// name: "Remote Island Vehicular Institute"
						// numberOfEmployees: 100
						// Other inherited properties ...

					} );
			</code></pre>
			</tab>
		</tabs>

		<p>
			With the previous example, we retrieved a simple document and printed all of its properties.
			Now, imagine that instead of all the properties, you only want the <i>name of the company</i> and the <i>number of employees</i> this company has.
			How would you do that?
		</p>
		<p>Well this is where querying comes into play.</p>

	</section>
	<!-- END: Getting a document -->


	<!-- START: Querying properties of a document -->
	<section class="mainContent-section">
		<h3>Querying properties of a document</h3>

		<p>
			To get a document with only some desired properties, a <i>query function</i> defining the desired properties should be passed to the <code>documents.get</code> method.<br>
		</p>


		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";
				import * as PersistedDocument from "carbonldp/PersistedDocument";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.get &lt;Client>( "clients/rivi/", _ => {   // Function defining the desired properties
					return _.properties( {
						"name": _.inherit,
						"numberOfEmployees": _.inherit
					} );
				} ).then( ( [ client, response ]:[ Client & PersistedDocument.Class, HTTP.Response.Class ] ) => {

					console.log( client );
					// name: "Remote Island Vehicular Institute"
					// numberOfEmployees: 100
					// Other inherited properties ...

				} );
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.get( "clients/rivi/", _ => {   // Function defining the desired properties
					return _.properties( {
						"name": _.inherit,
						"numberOfEmployees": _.inherit
					} );
				} ).then( ( [ client, response ] ) => {

					console.log( client );
					// name: "Remote Island Vehicular Institute"
					// numberOfEmployees: 100
					// Other inherited properties ...

				} );
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				carbon.documents.get( "clients/rivi/", function ( _ ) {   // Function defining the desired properties
					return _.properties( {
						"name": _.inherit,
						"numberOfEmployees": _.inherit
					} );
				} ).then( function ( result  ) => {

					var client = result[ 0 ];
					var response = result[ 1 ];

					console.log( client );
					// name: "Remote Island Vehicular Institute"
					// numberOfEmployees: 100
					// Other inherited properties ...

				} );
			</code></pre>
			</tab>
		</tabs>

		<p>
			What we did was to use a function that returns a <code>QueryDocumentBuilder</code> type of object that lets us construct a query with the desired properties
			by using the <code>properties</code> function.
			<!--But this helper function can also let us retrieve -->
		</p>

	</section>
	<!-- END: Querying properties of a document -->


	<!-- START: The query function -->
	<section class="mainContent-subSection">
		<h3>The query function</h3>

		<p>Take a look again at the function passed to the <code>get</code> method and let's break down its structure by parts:</p>

		<pre><code class="typescript">
				...
				carbon.documents.get &lt;Client>( "clients/rivi/", _ => {   // Function defining the desired properties
					return _.properties( {
						"name": _.inherit,
						"numberOfEmployees": _.inherit
					} );
				} )
				...
		</code></pre>

		<div class="ui ordered list">
			<div class="item">
				<div class="content">
					<div class="header">It's an anonymous function</div>
					<div class="description">
						It's an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function" target="_blank">anonymous function</a> that returns
						the result of calling the <span class="highlight">properties</span> function of the <span class="highlight">_</span> variable.
					</div>
				</div>
			</div>
			<div class="item">
				<div class="content">
					<div class="header">The underscore <span class="highlight">_</span> variable</div>
					<div class="description">
						<p>
							This is just the name suggested for the function's parameter that will help us build the query, feel free to use
							whichever name suits you better.
							This variable is a <code>QueryDocumentBuilder</code> type of object that, when used with the <code>get</code> method, let's us specify the
							<code>properties</code> to get from the document.
						</p>
					</div>
				</div>
			</div>
			<div class="item">
				<div class="content">
					<div class="header">The <code>_.inherit</code> property</div>
					<div class="description">
						<p>
							To build a query to get the desired properties of a document, we have to list them through the <code>_.properties</code> function.
							Because what we are passing to this functions is a <strong>JavaScript object</strong> with the desired <strong>properties</strong>,
							<i>we must assign a value to each property</i>, and since we do not know/nor care for the values of the properties because we just want them,
							the <code>_.inherit</code> instruction let's us do exactly that.<br>
							In a nutshell, the <code>_.inherit</code> property it's another way of saying <i>"I want property 'X' but I don't
								care/know which value or type that property has, just retrieve it"</i>.
						</p>
					</div>
				</div>
			</div>
		</div>

	</section>
	<!-- END: The query function -->


	<!-- START: Getting a document with a type -->
	<section class="mainContent-subSection">
		<h3>Getting a document with a type</h3>

		<div class="ui info icon message">
			<i class="info circle icon"></i>
			<div class="content">
				<p>
					If you have not worked with object schemas before or have no idea of what they are, please refer to the
					<a href="../object-schema#what-is-an-object-schema-" target="_blank">What is an object schema?</a>
					section, particularly the <a href="../object-schema#data-types-type-">Data Types (@type) section</a>, to better understand the use of types while querying.
				</p>
			</div>
		</div>

		<p>
			Carbon stores all of its documents with a property called <span class="highlight">@types</span>.
			This property allows us to better organize our information/documents to avoid name collisions by using the SDK's <a href="../object-schema#object-types" target="_blank">object schema's types </a>.
		</p>

		<p>
			When querying, you can make use of this property to improve your query performance by using the <code>_.withType</code> function before the
			<code>properties</code> function call, like this:
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";
				import * as PersistedDocument from "carbonldp/PersistedDocument";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a new Client type
				carbon.extendObjectSchema( "Client", {
					"name": {
						"@type": "string"
					},
					"countryOfOrigin": {
						"@type": "string"
					},
					"foundationYear": {
						"@type": "integer"
					},
					"numberOfEmployees": {
						"@type": "integer"
				    }
				} );

				// ... creating a query to fetch a Client type document using withType
				carbon.documents.get &lt;Client>( "clients/rivi/", _ => {
					return _.withType( "Client" )   // Setting the type in a query
						.properties( {   // Function defining the desired properties
							"name": _.inherit,
							"numberOfEmployees": _.inherit
						} );
				} ).then( ( [ client, response ]:[ Client & PersistedDocument.Class, HTTP.Response.Class ] ) => {

					console.log( client );
					// name: "Remote Island Vehicular Institute"
					// numberOfEmployees: 100
					// Other inherited properties ...

				} );
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a new Client type
				carbon.extendObjectSchema( "Client", {
					"name": {
						"@type": "string"
					},
					"countryOfOrigin": {
						"@type": "string"
					},
					"foundationYear": {
						"@type": "integer"
					},
					"numberOfEmployees": {
						"@type": "integer"
				    }
				} );

				// ... creating a query to fetch a Client type document using withType
				carbon.documents.get( "clients/rivi/", _ => {
					return _.withType( "Client" )   // Setting the type in a query
						.properties( {   // Function defining the desired properties
							"name": _.inherit,
							"numberOfEmployees": _.inherit
						} );
				} ).then( ( [ client, response ] ) => {

					console.log( client );
					// name: "Remote Island Vehicular Institute"
					// numberOfEmployees: 100
					// Other inherited properties ...

				} );
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a new Client type
				carbon.extendObjectSchema( "Client", {
					"name": {
						"@type": "string"
					},
					"countryOfOrigin": {
						"@type": "string"
					},
					"foundationYear": {
						"@type": "integer"
					},
					"numberOfEmployees": {
						"@type": "integer"
				    }
				} );

				// ... creating a query to fetch a Client type document using withType
				carbon.documents.get( "clients/rivi/", function ( _ ) {
					return _.withType( "Client" )   // Setting the type in a query
						.properties( {   // Function defining the desired properties
							"name": _.inherit,
							"numberOfEmployees": _.inherit
						} );
				} ).then( function ( result ) => {

					var client = result[ 0 ];
					var response = result[ 1 ];

					console.log( client );
					// name: "Remote Island Vehicular Institute"
					// numberOfEmployees: 100
					// Other inherited properties ...

				} );
			</code></pre>
			</tab>
		</tabs>

		<p>
			By doing this, we facilitate the SDK's type inference by saving time checking all the existing object schemas to find the
			type of value that each property will have. All of this while also building efficient queries by calling just the desired properties,
			which allows us to save time and data consumed by each call.
		</p>

	</section>
	<!-- END: Getting a document with a type -->


	<!-- START: Getting the members of a container -->
	<section class="mainContent-subSection">
		<h3>Getting the members of a container</h3>

		<p>
			Until here, we've just talked about two things: retrieving a <span class="highlight">document</span> with all of its properties and retrieving a document with some properties.<br>
		</p>
		<p>
			The SDK also allows us to get all the existing members and children from a single call by using the <code>getMembers</code> function.
			When using this function, an array of all the existing members with all of their properties will be returned.
		</p>
		<p>You can see this in the following code:</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";
				import * as PersistedDocument from "carbonldp/PersistedDocument";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a new Client type

				carbon.documents.getMembers &lt;Client>( "clients/" ).then( ( [ clients, response ]:[ Array&lt;Client & PersistedDocument.Class>, HTTP.Response.Class ] ) => {

					console.log( clients );
					// (3) [{…}, {…}, {…}]
					//	0:{_id: "http://localhost:8083/clients/peopletrucks/", _resolved: true, isResolved: ƒ, resolve: ƒ, …}
					//	1:{_id: "http://localhost:8083/clients/rivi/", _resolved: true, isResolved: ƒ, resolve: ƒ, …}
					//	2:{_id: "http://localhost:8083/clients/rpa/", _resolved: true, isResolved: ƒ, resolve: ƒ, …}

				} );
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a new Client type

				carbon.documents.getMembers( "clients/" ).then( ( [ clients, response ]) => {

					console.log( clients );
					// (3) [{…}, {…}, {…}]
					//	0:{_id: "http://localhost:8083/clients/peopletrucks/", _resolved: true, isResolved: ƒ, resolve: ƒ, …}
					//	1:{_id: "http://localhost:8083/clients/rivi/", _resolved: true, isResolved: ƒ, resolve: ƒ, …}
					//	2:{_id: "http://localhost:8083/clients/rpa/", _resolved: true, isResolved: ƒ, resolve: ƒ, …}

				} );
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a new Client type

				carbon.documents.getMembers( "clients/" ).then( function ( result ) => {

					var clients = result[ 0 ];
					var response = result[ 1 ];

					console.log( clients );
					// (3) [{…}, {…}, {…}]
					//	0:{_id: "http://localhost:8083/clients/peopletrucks/", _resolved: true, isResolved: ƒ, resolve: ƒ, …}
					//	1:{_id: "http://localhost:8083/clients/rivi/", _resolved: true, isResolved: ƒ, resolve: ƒ, …}
					//	2:{_id: "http://localhost:8083/clients/rpa/", _resolved: true, isResolved: ƒ, resolve: ƒ, …}

				} );
			</code></pre>
			</tab>
		</tabs>

		<p>
			Up until now, nothing new has happened. We just retrieved all the members of the <span class="highlight">clients/</span> container and printed them out.
			Like the <code>get</code> method of the <code>documents</code> service, <code>getMembers</code> also allows us to pass a query to be applied when retrieving the members,
			allowing us to fetch some desired properties on each one of them or even applying complex queries, like getting documents matching a filtering criteria, for example,
			getting all the clients with a number of employees greater than X, etc...
		</p>
		<p>
			In fact, let's use the <code>getMembers</code> querying functionality to fetch the <u>name of the company</u> and the <u>amount of employees</u> of those companies with
			<u>more than 100 employees</u>. In code, this requirement will be portrayed like this:
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";
				import * as PersistedDocument from "carbonldp/PersistedDocument";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a new Client type

				carbon.documents.getChildren &lt;Client> ( "clients/", _ => {
					return _.withType( "Client" )   // Setting the type
						.properties( {
							"name": _.inherit,
							"numberOfEmployees": _.inherit
						} )
						.filter( `${ _.property( "numberOfEmployees" ) } > ${ _.value( 100 ) }` )    // Setting the filter of employees
				} ).then( ( [ clients, response ]:[ Array&lt;Client & PersistedDocument.Class>, HTTP.Response.Class ] ) => {

					console.log( clients );
					//	(2) [{…}, {…}]
					//  0: {numberOfEmployees: 25000, _id: "http://localhost:8083/clients/peopletrucks/", _resolved: true, isResolved: ƒ, …}
					//  1: {numberOfEmployees: 150, _id: "http://localhost:8083/clients/rpa/", _resolved: true, isResolved: ƒ, …}

					console.log( clients.length ); // 2

				} ).catch( ( error ) => {
					console.error( error );
				} );
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a new Client type

				carbon.documents.getChildren( "clients/", _ => {
					return _.withType( "Client" )   // Setting the type
						.properties( {
							"name": _.inherit,
							"numberOfEmployees": _.inherit
						} )
						.filter( `${ _.property( "numberOfEmployees" ) } > ${ _.value( 100 ) }` )    // Setting the filter of employees
				} ).then( ( [ clients, response ] ) => {

					console.log( clients );
					//	(2) [{…}, {…}]
					//  0: {numberOfEmployees: 25000, _id: "http://localhost:8083/clients/peopletrucks/", _resolved: true, isResolved: ƒ, …}
					//  1: {numberOfEmployees: 150, _id: "http://localhost:8083/clients/rpa/", _resolved: true, isResolved: ƒ, …}

					console.log( clients.length ); // 2

				} ).catch( ( error ) => {
					console.error( error );
				} );
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a new Client type

				carbon.documents.getChildren( "clients/", function ( _ ) {
					return _.withType( "Client" )   // Setting the type
						.properties( {
							"name": _.inherit,
							"numberOfEmployees": _.inherit
						} )
						.filter( _.property( "numberOfEmployees" ) + " > " + _.value( 100 ) )    // Setting the filter of employees
				} ).then( function ( result ) {

					var clients = result[ 0 ];
					var response = result[ 1 ];

					console.log( clients );
					//	(2) [{…}, {…}]
					//  0: {numberOfEmployees: 25000, _id: "http://localhost:8083/clients/peopletrucks/", _resolved: true, isResolved: ƒ, …}
					//  1: {numberOfEmployees: 150, _id: "http://localhost:8083/clients/rpa/", _resolved: true, isResolved: ƒ, …}

					console.log( clients.length ); // 2

				} ).catch( ( error ) => {
					console.error( error );
				} );
			</code></pre>
			</tab>
		</tabs>

		<p>
			Now, let's take a closer look to the query function that we passed to the <code>getChildren</code> method.
		</p>

		<pre><code class="typescript">
				...
				carbon.documents.getChildren &lt;Client>( "clients/", _ => {
					return _.withType( "Client" )   // Setting the type
						.properties( {
							"name": _.inherit,
							"numberOfEmployees": _.inherit
						} ).filter( `${ _.property( "numberOfEmployees" ) } > ${ _.value( 100 ) }` )    // Setting the filter of employees
				} )
				...
		</code></pre>

		<p>It's pretty similar to the query function we used before, but in this case, we did the following two things:</p>
		<ol>
			<li>
				<strong>Set the type</strong>: we used the <code>.withType</code> function to easily match the properties when the SDK builds the JavaScript object.
			</li>
			<li>
				<strong>Defined desired properties</strong>: we used the <code>.properties</code> function to state the two properties we wanted,
				<span class="highlight">name</span> and <span class="highlight">numberOfEmployees</span>.
			</li>
			<li>
				<strong>Set a filter</strong>: we used the <code>.filter</code> function with a string containing the filter criteria.
				This filter is a string concatenating the result of calling <code>property</code> and the <code>value</code> functions.
			</li>
		</ol>

		<p>
			Notice how in the <code>filter</code> section of the query, we made use of the <code>property</code> and the <code>value</code> functions.
			These two functions come from the <code>QueryDocumentBuilder</code> class, and they can only be used when applying filters when creating the querying
			function.
		</p>

	</section>
	<!-- END: Getting the members of a container -->


	<!-- START: Querying through linked data -->
	<section class="mainContent-subSection">
		<h3>Querying through linked data</h3>
		<p>
			We just saw how to create querying functions using the <code>get</code>, <code>getMembers</code> and <code>getChildren</code>
			methods of the <code>documents</code> service. All of these examples were done by querying data living inside the same contents of a <code>Client</code> document.
			However, Carbon LDP stands for Linked Data Platform, and what it does is that Carbon allows you to easily link data, hence, these querying functionality
			can also be portrayed to <i>query through the links in your data!</i>
		</p>

		<h4>Example</h4>
		<p>
			Let's extend our example to now include a people container with three persons that will act as CEO's of each Client.
			Each CEO will be stored as a Person type of object inside <code>http://localhost:8083/people/</code>:
		</p>

		<pre><code class="typescript">
				[
					{
						// Document URI
						"@id": "http://localhost:8083/people/tim-pond/",
						// Types of the document
						"@types":[ "http://localhost:8083/vocabulary/#Person" ]

						// Properties
						name: "Tim Pond",
						age: 52,
					},
					{
						// Document URI
						"@id": "http://localhost:8083/people/steven-brown/",
						// Types of the document
						"@types":[ "http://localhost:8083/vocabulary/#Person" ]

						// Properties
						name: "Steven Brown",
						age: 56,
					},
					{
						// Document URI
						"@id": "http://localhost:8083/people/elena-tonks/",
						// Types of the document
						"@types":[ "http://localhost:8083/vocabulary/#Person" ]

						// Properties
						name: "Elena Tonks",
						age: 45,
					}
				];
		</code></pre>

		<p>
			The above is the representation of the three people living inside the <code>http://localhost:8083/people/</code> container, but now we need to link them
			back to each one of the Clients document. To do that, let's modify the body of each one of the Client document, like this:
		</p>


		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";
				import * as PersistedDocument from "carbonldp/PersistedDocument";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a Client type

				// ... extending object schema with a new Person type
				this.carbon.extendObjectSchema( "Person", {
					"name": {
						"@type": "string"
					},
					"age": {
						"@type": "integer"
					}
				} );

				let rpa:Client, peoplesTruck:Client, rivi:Client,
					tim:Person, steven:Person, elena:Person;

				// Fetch all the Clients
				carbon.documents.getChildren( "clients/" ).then( ( [ clients, response ]:[ Array&lt;Client & PersistedDocument.Class>, HTTP.Response.Class ] ) => {

					console.log( clients );

					rpa = clients.find( client => client.name === "Royal Psychology Association" );
					peoplesTruck = clients.find( client => client.name === "People's Truck" );
					rivi = clients.find( client => client.name === "Remote Island Vehicular Institute" );

					return this.carbon.documents.getChildren( "people/" );
				} )

				// Fetch all the people and assign them to a client
				.then( ( [ people, response ]:[ Array&lt;Person & PersistedDocument.Class>, HTTP.Response.Class ] ) => {

					tim = people.find( person => person.name === "Tim Pond" );
					steven = people.find( person => person.name === "Steven Brown" );
					elena = people.find( person => person.name === "Elena Tonks" );

					// Assigning a CEO to each client
					rpa.ceo = tim;
					peoplesTruck.ceo = steven;
					rivi.ceo = elena;

					// Persisting the clients
					return Promise.all( [ rpa.save(), peoplesTruck.save(), rivi.save() ] );
				} )
				.then( ( promises:any ) => {

					// Printing the results
					console.log( promises );
				} )
				.catch( ( error ) => {
					console.error( error );
				} );
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a Client type

				// ... extending object schema with a new Person type
				this.carbon.extendObjectSchema( "Person", {
					"name": {
						"@type": "string"
					},
					"age": {
						"@type": "integer"
					}
				} );

				let rpa, peoplesTruck, rivi,
					tim, steven, elena;

				// Fetch all the Clients
				carbon.documents.getChildren( "clients/" ).then( ( [ clients, response ] ) => {

					console.log( clients );

					rpa = clients.find( client => client.name === "Royal Psychology Association" );
					peoplesTruck = clients.find( client => client.name === "People's Truck" );
					rivi = clients.find( client => client.name === "Remote Island Vehicular Institute" );

					return this.carbon.documents.getChildren( "people/" );
				} )

				// Fetch all the people and assign them to a client
				.then( ( [ people, response ] ) => {

					tim = people.find( person => person.name === "Tim Pond" );
					steven = people.find( person => person.name === "Steven Brown" );
					elena = people.find( person => person.name === "Elena Tonks" );

					// Assigning a CEO to each client
					rpa.ceo = tim;
					peoplesTruck.ceo = steven;
					rivi.ceo = elena;

					// Persisting the clients
					return Promise.all( [ rpa.save(), peoplesTruck.save(), rivi.save() ] );
				} )
				.then( ( promises ) => {

					// Printing the results
					console.log( promises );
				} )
				.catch( ( error ) => {
					console.error( error );
				} );
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a Client type

				// ... extending object schema with a new Person type
				this.carbon.extendObjectSchema( "Person", {
					"name": {
						"@type": "string"
					},
					"age": {
						"@type": "integer"
					}
				} );

				let rpa, peoplesTruck, rivi,
					tim, steven, elena;

				// Fetch all the Clients
				carbon.documents.getChildren( "clients/" ).then( function ( result ) {

					var clients = result[ 0 ];
					var response = result[ 1 ];

					console.log( clients );

					rpa = clients.find( client => client.name === "Royal Psychology Association" );
					peoplesTruck = clients.find( client => client.name === "People's Truck" );
					rivi = clients.find( client => client.name === "Remote Island Vehicular Institute" );

					return this.carbon.documents.getChildren( "people/" );
				} )

				// Fetch all the people and assign them to a client
				.then( function ( result ) {

					var people = result[ 0 ];
					var response = result[ 1 ];

					tim = people.find( person => person.name === "Tim Pond" );
					steven = people.find( person => person.name === "Steven Brown" );
					elena = people.find( person => person.name === "Elena Tonks" );

					// Assigning a CEO to each client
					rpa.ceo = tim;
					peoplesTruck.ceo = steven;
					rivi.ceo = elena;

					// Persisting the clients
					return Promise.all( [ rpa.save(), peoplesTruck.save(), rivi.save() ] );
				} )
				.then( ( result ) => {

					var promises = result[ 0 ];

					// Printing the results
					console.log( promises );
				} )
				.catch( ( error ) => {
					console.error( error );
				} );
			</code></pre>
			</tab>
		</tabs>

		<p>
			With the previous snippet, we just assigned a CEO to each client, now we can start to create linked queries!
			Without further ado, let's create a query that returns the <u>clients with CEO's</u> that are <u>older than 50 years old</u>.
		</p>

		<h4>Example</h4>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as HTTP from "carbonldp/HTTP";
				import * as PersistedDocument from "carbonldp/PersistedDocument";

				let carbon:Carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a Client type

				// ... extending object schema with a new Person type

				carbon.documents.getChildren&lt;Client>( "clients/", _ => {
					return _.withType( "Client" )   // Setting the type
						.properties( {
							"name": _.inherit,
							"numberOfEmployees": _.inherit,
							"ceo": {
								"@type": "@id",
								"query": _ => _
									.properties( {
										"name": _.inherit,
										"age": _.inherit,
									} )
								// .filter( `${ _.property( "age" ) } > ${ _.value( 50 ) }` )
							}
						} )
						.filter( `${ _.property( "ceo.age" ) } > ${ _.value( 50 ) }` )
				} ).then( ( [ clients, response ]:[ Array&lt;Client & PersistedDocument.Class>, HTTP.Response.Class ] ) => {

					console.log( clients );
					// (2) [{…}, {…}]
					// 	0: {ceo: {…}, name: "People's Truck", numberOfEmployees: 25000, _id: "http://localhost:8083/clients/peoplestruck/", …}
					// 	1: {ceo: {…}, name: "Royal Psychology Association", numberOfEmployees: 150, _id: "http://localhost:8083/clients/rpa/", …}length: 2__proto__: Array(0)

					console.log( clients.length ); // 2
					console.log( "Company: %o, Ceo: %o, Age: %o", clients[ 0 ].name, clients[ 0 ].ceo.name, clients[ 0 ].ceo.age );
					// Company: "People's Truck", Ceo: "Steven Brown", Age: 56
					console.log( "Company: %o, Ceo: %o, Age: %o", clients[ 1 ].name, clients[ 1 ].ceo.name, clients[ 1 ].ceo.age );
					// Company: "Royal Psychology Association", Ceo: "Tim Pond", Age: 52

				} ).catch( ( error ) => {
					console.error( error );
				} );
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a Client type

				// ... extending object schema with a new Person type

				carbon.documents.getChildren( "clients/", _ => {
					return _.withType( "Client" )   // Setting the type
						.properties( {
							"name": _.inherit,
							"numberOfEmployees": _.inherit,
							"ceo": {
								"@type": "@id",
								"query": _ => _
									.properties( {
										"name": _.inherit,
										"age": _.inherit,
									} )
								// .filter( `${ _.property( "age" ) } > ${ _.value( 50 ) }` )
							}
						} )
						.filter( `${ _.property( "ceo.age" ) } > ${ _.value( 50 ) }` )
				} ).then( ( [ clients, response ] ) => {

					console.log( clients );
					// (2) [{…}, {…}]
					// 	0: {ceo: {…}, name: "People's Truck", numberOfEmployees: 25000, _id: "http://localhost:8083/clients/peoplestruck/", …}
					// 	1: {ceo: {…}, name: "Royal Psychology Association", numberOfEmployees: 150, _id: "http://localhost:8083/clients/rpa/", …}length: 2__proto__: Array(0)

					console.log( clients.length ); // 2
					console.log( "Company: %o, Ceo: %o, Age: %o", clients[ 0 ].name, clients[ 0 ].ceo.name, clients[ 0 ].ceo.age );
					// Company: "People's Truck", Ceo: "Steven Brown", Age: 56
					console.log( "Company: %o, Ceo: %o, Age: %o", clients[ 1 ].name, clients[ 1 ].ceo.name, clients[ 1 ].ceo.age );
					// Company: "Royal Psychology Association", Ceo: "Tim Pond", Age: 52

				} ).catch( ( error ) => {
					console.error( error );
				} );
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var carbon;

				// ... initialize your Carbon object

				// ... authenticate if needed

				// ... extending object schema with a Client type

				// ... extending object schema with a new Person type

				carbon.documents.getChildren( "clients/", function ( _ ) {
					return _.withType( "Client" )   // Setting the type
						.properties( {
							"name": _.inherit,
							"numberOfEmployees": _.inherit,
							"ceo": {
								"@type": "@id",
								"query": _ => _
									.properties( {
										"name": _.inherit,
										"age": _.inherit,
									} )
								// .filter( _.property( "age" ) + " > " + _.value( 50 ) )
							}
						} )
						.filter( _.property( "ceo.age" ) + " > " + _.value( 50 ) )
				} ).then( ( result ) => {

					var clients = result[ 0 ];
					var response = result[ 1 ];

					console.log( clients );
					// (2) [{…}, {…}]
					// 	0: {ceo: {…}, name: "People's Truck", numberOfEmployees: 25000, _id: "http://localhost:8083/clients/peoplestruck/", …}
					// 	1: {ceo: {…}, name: "Royal Psychology Association", numberOfEmployees: 150, _id: "http://localhost:8083/clients/rpa/", …}length: 2__proto__: Array(0)

					console.log( clients.length ); // 2
					console.log( "Company: %o, Ceo: %o, Age: %o", clients[ 0 ].name, clients[ 0 ].ceo.name, clients[ 0 ].ceo.age );
					// Company: "People's Truck", Ceo: "Steven Brown", Age: 56
					console.log( "Company: %o, Ceo: %o, Age: %o", clients[ 1 ].name, clients[ 1 ].ceo.name, clients[ 1 ].ceo.age );
					// Company: "Royal Psychology Association", Ceo: "Tim Pond", Age: 52

				} ).catch( ( error ) => {
					console.error( error );
				} );
			</code></pre>
			</tab>
		</tabs>


		<br>
		<p>
			Again, let's take a closer look to the query function that we passed to the <code>getChildren</code> method.
		</p>

		<pre><code class="typescript">
				...
				carbon.documents.getChildren&lt;Client>( "clients/", _ => {
					return _.withType( "Client" )   // 1. Setting the type
						.properties( {  // 2. Setting the properties
							"name": _.inherit,
							"numberOfEmployees": _.inherit,
							"ceo": {    // 3. Setting the connecting property
								"@type": "@id",
								"query": _ => _
									.properties( {
										"name": _.inherit,
										"age": _.inherit,
									} )
								// .filter( `${ _.property( "age" ) } > ${ _.value( 50 ) }` )   // 4. Sub-query filter
							}
						} )
						.filter( `${ _.property( "ceo.age" ) } > ${ _.value( 50 ) }` )  // 4. Sub-query filter
				} )
				...
		</code></pre>

		<p>
			This time, the querying function is different than before. What we must stand out when building queries against linked data is that we use inner querying
			functions defining the properties to retrieve and values to filter out from the linked endpoint. Let's debunk this function, piece by piece:
		</p>
		<ol>
			<li>
				<strong>Set the type</strong>: we used the <code>.withType</code> function to easily match the properties when the SDK builds the JavaScript object.
			</li>
			<li>
				<strong>Define desired properties</strong>: we used the <code>.properties</code> function to state the properties we want,
				<span class="highlight">name</span>, <span class="highlight">numberOfEmployees</span> and the ceo <span class="highlight">ceo</span> object.
			</li>
			<li>
				<strong>Set the connection property</strong>: we used the <code>@type</code> property to tell the SDK that the property <code>ceo</code> will be a pointer/link
				to another object, that's why we use the <code>@id</code> value. We are also saying that for this property, we will use a query selecting the properties we want
				from the linked object. In this case we wan the <span class="highlight">name</span> and the <span class="highlight">age</span> of the CEO.
			</li>
			<li>
				<strong>Set a filter</strong>: we used the <code>.filter</code> function with a string containing the filter criteria.
				Notice how we can use the filter within the <u>inner querying function</u> or in the <u>general querying function</u>. You can use place the filter
				wherever you want, but if you place it in the general function, be aware to use dot notation to state the properties to apply the filter, which in this case
				was <code>ceo.age</code>.
			</li>
		</ol>

	</section>
	<!-- END: Getting the members of a container -->


	<!-- START: Querying through linked data -->
	<section class="mainContent-subSection">
		<h3>Ordering and limiting results</h3>

		<p>
			Other potential features we can make use of while creating queries, are the ability to <u>sort</u> the results of the queries and <u>limiting</u> the results to
			easily implement pagination in your UI. To accomplish this, let's use the last example but this time, we will sort the clients by number of employees in ascending
			order but limiting the results by one.<br>
			The code would be:
		</p>


		<pre><code class="typescript">
				...
				carbon.documents.getChildren&lt;Client>( "clients/", _ => {
					return _.withType( "Client" )
						.properties( {
							"name": _.inherit,
							"numberOfEmployees": _.inherit,
							"ceo": {
								"@type": "@id",
								"query": _ => _
									.properties( {
										"name": _.inherit,
										"age": _.inherit,
									} )
								// .filter( `${ _.property( "age" ) } > ${ _.value( 50 ) }` )
							}
						} )
						// .filter( `${ _.property( "ceo.age" ) } > ${ _.value( 50 ) }` )
						.orderAscendantBy( _.property( "numberOfEmployees" ) )
						.limit( 1 )
						.offset( 0 )
				} )
				...
		</code></pre>

		<p>
			We just commented out the filter parts because our data set is too small, we only have 3 clients. In this example, we just created a query that sorts the clients by the
			number of employees in ascending way. By limiting the results one by one (<code>.limit( 1 )</code>) and using the offset of 0 (<code>.offset(0)</code>) we are
			fetching the client with the lowest number of employees. If we would like the second, we could use <code>.offset(1)</code> to get the next client with the lowest
			value. If you take a look at this pattern, we are emulating pagination, but limited by 1 element per page (<code>.limit(&nbsp;1&nbsp;)</code>) and selecting the
			first page of the data set (<code>.offset( 0 )</code>).
		</p>

		<p>
			Alternatively we could just simply get all the clients and sort them out without having to limit the results. To accomplish that, we just have to remove the
			<code>limit</code> and the <code>offset</code> from the query, like this:
		</p>


		<pre><code class="typescript">
				...
				carbon.documents.getChildren&lt;Client>( "clients/", _ => {
					return _.withType( "Client" )
						.properties( {
							"name": _.inherit,
							"numberOfEmployees": _.inherit,
							"ceo": {
								"@type": "@id",
								"query": _ => _
									.properties( {
										"name": _.inherit,
										"age": _.inherit,
									} )
								// .filter( `${ _.property( "age" ) } > ${ _.value( 50 ) }` )
							}
						} )
						// .filter( `${ _.property( "ceo.age" ) } > ${ _.value( 50 ) }` )
						.orderAscendantBy( _.property( "numberOfEmployees" ) )
				} )
				...
		</code></pre>

		<p>The results are the following:</p>

		<pre><code class="typescript">
				(3) [{…}, {…}, {…}]
					0:{ceo: {…}, name: "Remote Island Vehicular Institute", numberOfEmployees: 100, _id: "http://localhost:8083/clients/rivi/", …}
					1:{ceo: {…}, name: "Royal Psychology Association", numberOfEmployees: 150, _id: "http://localhost:8083/clients/rpa/", …}
					2:{ceo: {…}, name: "People's Truck", numberOfEmployees: 25000, _id: "http://localhost:8083/clients/peoplestruck/", …}
		</code></pre>

	</section>
	<!-- END: Querying through linked data -->

</section>
<!-- END: Using the documents service -->


<!-- START: Conclusion -->
<section class="mainContent-section">
	<h2>Conclusion</h2>

	<p>In this guide, we've demonstrated two alternative ways to query with SPARQL using the SDK:</p>

	<ul>
		<li>Using the <strong>SPARQL Query Builder</strong> (a.k.a. SPARQLER) - a fluent chain of methods assembled in a dot-notation to build up a query.</li>
		<li>Using <strong>SPARQL Services</strong> - methods that accept a standard SPARQL query string passed in a parameter to the method.</li>
	</ul>

	<p>We also provided an overview, with code examples, for the different query forms <code>SELECT</code>, <code>ASK</code>, <code>CONSTRUCT</code>, <code>DESCRIBE</code>, and <code>UPDATE</code>.</p>

</section>
<!-- END: Conclusion -->

<div class="ui section divider"></div>


<h3>Want to know more?</h3>

<p>Now that you understand how to query with SPARQL using the SDK, you may want to learn more about the SPARQL language. We recommend the following references:</p>

<div class="ui list">
	<div class="item">
		<img class="ui avatar image" src="/assets/images/ld_icons_rdf_83x83.png" alt="RDF Icon"/>
		<div class="content">
			<a class="header" href="https://www.w3.org/TR/sparql11-overview/"><strong>SPARQL 1.1 Overview</strong></a>
			<div class="description">Introduction from the W3C.</div>
		</div>
	</div>
	<div class="item">
		<img class="ui avatar image" src="/assets/images/ld_icons_rdf_83x83.png" alt="RDF Icon"/>
		<div class="content">
			<a class="header" href="https://www.w3.org/TR/sparql11-query/"><strong>SPARQL 1.1 Query Language</strong></a>
			<div class="description">Specification from the W3C.</div>
		</div>
	</div>
	<div class="item">
		<img class="ui avatar image" src="/assets/images/ld_icons_rdf_83x83.png" alt="RDF Icon"/>
		<div class="content">
			<a class="header" href="https://www.amazon.com/Learning-SPARQL-Querying-Updating-1-1/dp/1449371434"><strong>Learning SPARQL</strong></a>
			<div class="description">Book about <em>Querying and Updating with SPARQL 1.1</em>, by Bob DuCharme, O'REILLY<sup>&reg;</sup>.</div>
		</div>
	</div>
</div>

<div class="ui section divider"></div>

<div class="documentation-steps ui fluid steps">
	<a class="step" href="../files">
		<i class="arrow left icon"></i>
		<div class="content">
			<div class="title">Previous</div>
			<div class="description">Files</div>
		</div>
	</a>
	<div class="active step">
		<!--<i class="payment icon"></i>-->
		<div class="content">
			<div class="title">Querying</div>
		</div>
	</div>
	<a class="step" href="../authentication">
		<i class="arrow right icon"></i>
		<div class="content">
			<div class="title">Next</div>
			<div class="description">Authentication</div>
		</div>
	</a>
</div>
