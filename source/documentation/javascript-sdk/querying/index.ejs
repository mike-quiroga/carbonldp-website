---
layout: document
title: Querying
description: Carbon LDP is a Linked Data Platform for building web apps that manage and link data within your enterprise and across the World Wide Web.
date: 2017-02-08 11:57:36
---

<h1>Querying</h1>

<div class="documentation-steps ui fluid steps">
	<a class="step" href="../files">
		<i class="arrow left icon"></i>
		<div class="content">
			<div class="title">Previous</div>
			<div class="description">Files</div>
		</div>
	</a>
	<div class="active step">
		<!--<i class="payment icon"></i>-->
		<div class="content">
			<div class="title">Querying</div>
		</div>
	</div>
	<a class="step" href="../authentication">
		<i class="arrow right icon"></i>
		<div class="content">
			<div class="title">Next</div>
			<div class="description">Authentication</div>
		</div>
	</a>
</div>

<div class="ui mobile only grid">
	<div class="row">
		<staticContentMenu content="mainContent"></staticContentMenu>
	</div>
</div>

<section class="mainContent-section">
	<h2 class="hidden">Introduction</h2>

	<p>
		Like the tables of a relational database are queried using SQL, Carbon LDP resources can be queried using
		<a href="https://www.w3.org/TR/sparql11-query/">SPARQL</a>, which is a W3C standard supported by the platform.
	</p>

	<p>
		Every document in the platform is an endpoint where you can apply an SPARQL query of the following forms:
	</p>
	<ul>
		<li><strong>SELECT</strong></li>
		<ul>Returns the selected data specified by one or more patterns (we'll explain them later on).</ul>
		<li><strong>ASK</strong></li>
		<ul>Returns a boolean indicating whether one or more patterns match or not.</ul>
		<li><strong>CONSTRUCT</strong></li>
		<ul>Constructs a non persisted document given one or more patterns as template.</ul>
		<li><strong>DESCRIBE</strong></li>
		<ul>Returns a description of how the data is internally stored.</ul>
	</ul>

	<p>
		A pattern is a way to refer any value, stored in the platform, using three elements:
	</p>
	<ol>
		<li><strong>Resource</strong>: any document, fragment or named fragment referenced by a URI</li>
		<li><strong>Property</strong>: the name or URI of a property of the resource</li>
		<li>And <strong>value</strong>: the value of the property</li>
	</ol>
	<p>
		This said, if we have a project stored with a property <code>name</code> with the value <code>"Project X"</code>,
		its pattern would be:
	</p>
	<ol>
		<li><strong>Resource</strong>: <code>projects/project-01/</code> (project URI)</li>
		<li><strong>Property</strong>: <code>name</code></li>
		<li>And <strong>value</strong>: <code>"Project X"</code></li>
	</ol>

	<p>
		This example pattern is a static one, because we are not asking for any resource just stabilising that this
		value of this property of this resource exists. Any element of the three indicated in the pattern,
		can be replaced by a variable, making possible, as this section is named, to query them.
	</p>

	<p>
		<strong>Example:</strong>
		To query the name of the project you only need the project URI (resource) and the name (property),
		the value would be represented by a variable in which you will obtain the data you queried for.
	</p>

	<p>
		Now, you may be asking: "what about modifying a document like <code>UPDATE</code> or <code>ALTER</code>?".
		For that cases the platform also supports <a href="https://www.w3.org/TR/sparql11-update/">SPARQL UPDATE</a>, another W3C standard,
		that lets you add or delete any data (really, ANY data).
		Because of this, SPARQL UPDATE is only available for system administrator users for now,
		but we are working in making it more secure and available to more users.
	</p>
</section>

<section class="mainContent-section">
	<h2>SPARQL Query Builder</h2>

	<p>
		The SDK integrates our own query builder called <a href="https://github.com/CarbonLDP/sparqler">SPARQLER</a> (SPARQL
		query buildER) which offers a <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a> to help you
		construct easier queries and prevent errors by malformed patterns.
	</p>

	<div class="ui info icon message">
		<i class="info circle icon"></i>
		<div class="content">
			<p>
				Currently, we only support <code>SELECT</code> queries with SPARQLER.<br/>
				We're working to extend the builder to cover more features.
			</p>
		</div>
	</div>

	<p>
		To create a query you must call the method <code>sparql( documentURI:string )</code> of the <code>Documents</code>
		service where you must provide document URI.
	</p>
	<p>
		If you already have a <code>PersistedDocument</code> you can call <code>sparql()</code>,
		where the document URI will be assumed to be the URI of this persisted document.
	</p>

	<tabs>
		<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import * as PersistedDocument from "carbonldp/PersistedDocument";

				let appContext:App.Context;
				// ... get context
				appContext.documents.sparql( "resource-end-point/" )
					// ... query construction
					;


				let persistedDocument:PersistedDocument.Class;
				// ... get the persistedDocument
				persistedDocument.sparql()
					// ... query construction
					;
			</code></pre>
		</tab>
		<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context
				appContext.documents.sparql( "resource-end-point/" )
					// ... query construction
					;


				let persistedDocument;
				// ... get the persistedDocument
				persistedDocument.sparql()
					// ... query construction
					;
				</code></pre>
		</tab>
		<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context
				appContext.documents.sparql( "resource-end-point/" )
					// ... query construction
					;


				var persistedDocument;
				// ... get the persistedDocument
				persistedDocument.sparql()
					// ... query construction
					;
			</code></pre>
		</tab>
	</tabs>

	<section class="mainContent-subSection">
		<h3>Query configuration</h3>
		<p>
			With the SPARQLER integration, every query have the following default information:
		</p>
		<ul>
			<li><strong>Prefixes</strong>. Every prefix in the global schema</li>
			<li><strong>Vocabulary</strong>. The application vocabulary to resolve property names, as in the <a href="http://localhost:4000/documentation/javascript-sdk/object-schema/#vocabularies">Object Schema</a></li>
			<li><strong>Base</strong>. The URI of the current context to resolve relative resources. In the case of an <code>App.Context</code> it is the app URI.</li>
		</ul>

		<p>
			To configure the builder to your own preferences you can use the following methods:
		</p>
		<ul class="list">
			<li><code>vocab( uri:string )</code>: Set or replace the existing vocabulary</li>
			<li><code>base( uri:string )</code>: Replace the base URI</li>
			<li><code>prefix( name:string, uri:string )</code>: Add or replace existing prefixes in the SPARQLER</li>
		</ul>

		<h4>Example</h4>
		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";

				let appContext:App.Context;
				// ... get context

				appContext.documents.sparql( "resource-end-point/" )
					// Sets a well defined vocabulary
					.vocab( "https://schema.org/" )

					// Sets the base to the document end point
					.base( "resource-end-point/" )

					// Adds new prefixes that may be used in the document
					.prefix( "bib": "https://bib.schema.org/" )
					.prefix( "auto": "https://auto.schema.org/" )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.sparql( "resource-end-point/" )
					// Sets a well defined vocabulary
					.vocab( "https://schema.org/" )

					// Sets the base to the document end point
					.base( "resource-end-point/" )

					// Adds new prefixes that may be used in the document
					.prefix( "bib": "https://bib.schema.org/" )
					.prefix( "auto": "https://auto.schema.org/" )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.sparql( "resource-end-point/" )
					// Sets a well defined vocabulary
					.vocab( "https://schema.org/" )

					// Sets the base to the document end point
					.base( "resource-end-point/" )

					// Adds new prefixes that may be used in the document
					.prefix( "bib": "https://bib.schema.org/" )
					.prefix( "auto": "https://auto.schema.org/" )
					;
			</code></pre>
			</tab>
		</tabs>
	</section>
</section>

<section class="mainContent-section">
	<h2>SELECT Query</h2>

	<section class="mainContent-subSection">
		<h3>General structure</h3>
		<p>
			Most SPARQL SELECT queries have the following structure and order:
		</p>
		<ol>
			<li>Select what data to include in the response:</li>
			<ul>
				<li><code>.select()</code> or <code>.selectAll()</code></li>
			</ul>
			<li>Specify the patterns to match:</li>
			<ul>
				<li><code>.where()</code></li>
			</ul>
			<li>Add optional solution modifiers:</li>
			<ul>
				<li><code>.groupBy()</code></li>
				<li><code>.having()</code></li>
				<li><code>.orderBy()</code></li>
				<li><code>.limit()</code></li>
				<li><code>.offset()</code></li>
			</ul>
			<li>Execute the query:</li>
			<ul>
				<li><code>.execute()</code> or <code>.executeRaw()</code></li>
			</ul>
		</ol>
	</section>

	<section class="mainContent-subSection">
		<h3>Data Selection</h3>
		<p>
			As seen previously, a SELECT query must have at least two elements:
			which variables to be in the resulted solutions and
			the patterns to match.
		</p>

		<p>
			We can specify which variables to be included by two methods:
		</p>
		<ul class="list">
			<li><code>.select( ...variables:string[] )</code>. Specify a set of variables to be included in the result</li>
			<li><code>.selectAll()</code>. Indicate that all variables that appears in the patterns will be included in the result</li>
		</ul>

		<p>
			In the case of the pattern to match, it's a little different since you need to provide a functionwhere you can
			construct that pattern:
		</p>
		<ul>
			<li><code>.where( patternFunction:( builder:PatternBuilder ) => GraphPattern )</code>. A single pattern to match</li>
			<li><code>.where( patternFunction:( builder:PatternBuilder ) => GraphPattern[] )</code>. Multiple patterns to match</li>
		</ul>
		<p>
			As you can see, the <code>patternFunction</code> receives an <code>SPARQL/PatternBuilder</code>
			which is an object that contains helper properties and functions to construct the patterns you need.
		</p>

		<h4>Example 01</h4>
		<p>
			Assuming we have the following object stored, we'll retrieve the name and start date of it:
		</p>
		<pre><code class="javascript">
			// Representation of the stored object
			{
				// Document URI
				"id": "http://localhost:8083/apps/my-app/projects/project-01/",

				// Properties
			    "name": "Project X",
				"startDate": "2017/02/19"

				// ...
			}
		</code></pre>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import { PatternBuilder } from "sparqler/PatternBuilder";

				let appContext:App.Context;
				// ... get context

				appContext.documents.sparql( "projects/project-01/" )
					.select( "projectName", "projectStart" )
					.where( ( _:PatternBuilder ) => {
						return _.resource( "projects/project-01/" )
							.has( "name", _.var( "projectName" ) )
							.and( "startDate", _.var( "projectStart" ) );
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.sparql( "projects/project-01/" )
					.select( "projectName", "projectStart" )
					.where( _ => {
						return _.resource( "projects/project-01/" )
							.has( "name", _.var( "projectName" ) )
							.and( "startDate", _.var( "projectStart" ) );
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.sparql( "projects/project-01/" )
					.select( "projectName", "projectStart" )
					.where( function( _ ) {
						return _.resource( "projects/project-01/" )
							.has( "name", _.var( "projectName" ) )
							.and( "startDate", _.var( "projectStart" ) );
					} )
					;
			</code></pre>
			</tab>
		</tabs>

		<p>
			In the example we list two variables to be included in the solution: <code>projectName</code>
			and <code>projectStart</code>. This variables should appear in the pattern to match, to indicate from where the
			solution data will be obtained.
		</p>
		<p>
			In the <code>.where()</code> method, we use the <code>PatternBuilder</code> to first indicate we are targeting a resource
			with the URI: <code>projects/project-01/</code>, and as the URI is relative, it will be resolved to <code>http://localhost:8083/apps/my-app/projects/project-01/</code>.
		</p>
		<p>
			From this resource we call the <code>has()</code>method,
			where we indicate that the resource have a property called <code>name</code>,
			and then bound its value to the variable <code>projectName</code>.
		</p>
		<p>
			Next we call the <code>and()</code> method,
			where we also indicate that the value of the property <code>startDate</code>, of the same resource,
			will be bound to the variable <code>projectStart</code>.
		</p>

		<h4>Example 02</h4>
		<p>
			In the case that we want to retrieve the name and start date from all the projects available,
			we need to take on count the next statements:
		</p>
		<ul class="list">
			<li>The end-point of the query must be the container of the projects: <code>projects/</code></li>
			<li>The children of the container are under the property: <code>http://www.w3.org/ns/ldp#contains</code></li>
			<li>We need to bind every child document (project) and ask for its name and start date, as the previous example</li>
		</ul>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import { PatternBuilder } from "sparqler/PatternBuilder";

				let appContext:App.Context;
				// ... get context

				appContext.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( ( _:PatternBuilder ) => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( _ => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( function( _ ) {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					;
			</code></pre>
			</tab>
		</tabs>

		<p>
			As we can see, the major difference is that we return of an array of patterns. The first pattern matches the child
			documents form the <code>projects/</code> container and bind them to the <code>everyProject</code> variable.
			Thus with this variable we can ask for the name and start date of every corresponding project.
		</p>

	</section>

	<section class="mainContent-subSection">
		<h3>Solution modifiers</h3>
		<p>
			This methods are optional and they let you modify the solutions returned:
		</p>
		<ul>
			<li>
				<code>.groupBy( rawCondition:string )</code>. Group the data in order to calculate aggregated values for a solution
			</li>
			<li>
				<code>.having( rawCondition:string )</code>. Filter grouped solution sets
			</li>
			<li>
				<code>.orderBy( rawCondition:string )</code>. Establish the order of the a sequence of solutions
			</li>
			<li>
				<code>.limit( limit:string )</code>. Restrict the number of solutions returned
			</li>
			<li>
				<code>.offset( offset:string )</code>. Control where the solutions returned start from the overall set of them
			</li>
		</ul>

		<h4>Example</h4>
		<p>
			Considering the same case of retrieving the name and start date of every project, but with the solutions modifiers
			we'll retrieve the last 10 projects that have been started.
		</p>
		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import { PatternBuilder } from "sparqler/PatternBuilder";

				let appContext:App.Context;
				// ... get context

				appContext.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( ( _:PatternBuilder ) => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( _ => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( function( _ ) {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					;
			</code></pre>
			</tab>
		</tabs>

		<p>
			To be able of retrieving the last started projects we use the <code>.orderBy()</code>
			method, and as for now SPARQLER only accepts RAW strings, we specify in that the solutions must be sorted in
			descendant order, with <code>DESC</code>, by the value of the variable <code>projectStart</code> (and yes, the variable needs the
			<code>?</code> at the beginning).
		</p>
		<p>
			Lastly we limit the solutions to the first 10 elements in the set with the <code>.limit()</code> method.
		</p>
	</section>

	<section class="mainContent-subSection">
		<h3>Query execution</h3>

		<p>
			Until now we've only been building the query and nothing more, but the important thing is to execute it and use the
			solutions returned.
		</p>
		<p>
			For a SELECT query we have two methods:
		</p>
		<ul>
			<li>
				<code>.execute()</code>. Return a promise with the parsed result as described in: <code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-SPARQL-SELECTResults-Class">Carbon.SPARQL.SELECTResults.Class</a></code>
			</li>
			<li>
				<code>.executeRaw()</code>. Return a promise with the JSON results as described in the <a href="https://www.w3.org/TR/2013/REC-sparql11-results-json-20130321/#select-results-form">specification</a>: <code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-SPARQL-RawResults-Class">Carbon.SPARQL.RawResults.Class</a></code>
			</li>
		</ul>

		<h4>Example</h4>
		<p>
			Following the previous examples, we'll execute the query we have been building and then return an array of projects with
			the data obtained.
		</p>
		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import * as SPARQL from "carbonldp/SPARQL";
				import * as HTTP from "carbonldp/HTTP";
				import { PatternBuilder } from "sparqler/PatternBuilder";

				let appContext:App.Context;
				// ... get context

				appContext.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( ( _:PatternBuilder ) => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					.execute()
					.then( ( [ result, response ]:[ SPARQL.SELECTResults.Class, HTTP.Response.Class ] ) => {
						return result
							.bindings
							.map( binding => ( {
								name: binding[ "projectName" ],
								startDate: binding[ "projectStart" ],
							} )
							;
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( _ => {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					.execute()
					.then( ( [ result, response ] ) => {
						return result
							.bindings
							.map( binding => ( {
								name: binding[ "projectName" ],
								startDate: binding[ "projectStart" ],
							} )
							;
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.sparql( "projects/" )
					.prefix( "ldp", "http://www.w3.org/ns/ldp#" )
					.select( "projectName", "projectStart" )
					.where( function( _ ) {
						return [
							_.resource( "projects/" )
								.has( "ldp:contains", _.var( "everyProject" ) ),
							_.var( "everyProject" )
								.has( "name", _.var( "projectName" ) )
								.and( "startDate", _.var( "projectStart" ) )
						];
					} )
					.orderBy( "DESC( ?projectStart )" )
					.limit( 10 )
					.execute()
					.then( function( [ result, response ] ) {
						return result
							.bindings
							.map( function( binding ) {
								return {
									name: binding[ "projectName" ],
									startDate: binding[ "projectStart" ],
								};
							} )
							;
					} )
					;
			</code></pre>
			</tab>
		</tabs>

		<p>
			The result object contains a property <code>bindings</code>, which is an array containing the solutions of
			the query. Every element in this array is an object that have the variable names retrieved as keys and its
			bound value, so we construct our own specific objects from them.
		</p>

	</section>

</section>


<section class="mainContent-section">
	<h2 class="hidden">SPARQL Services</h2>

	<p>
		If you already have your queries made or even want to use features not available in SPARQLER, the SDK offers
		methods where you only need to provide the query string in order to execute it. The only feature not available
		is the use of relative property names, given that the SPARQL specification do not have default vocabulary option.
	</p>
	<p>
		This methods are also called from the <code>Documents</code> service.
	</p>

	<section class="mainContent-subSection">
		<h3>SELECT Queries</h3>
		<ul>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeSELECTQuery">executeSELECTQuery</a>( documentURI:string, selectQuery: string )</code></li>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeRawSELECTQuery">executeRawSELECTQuery</a>( documentURI:string, selectQuery: string )</code></li>
		</ul>
		<p>
			This methods are the equivalent to the <code>.execute()</code> and <code>.executeRaw()</code> in a SELECT
			query with the Query Builder.
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import * as SPARQL from "carbonldp/SPARQL";
				import * as HTTP from "carbonldp/HTTP";

				let appContext:App.Context;
				// ... get context

				appContext.documents.executeSELECTQuery( "projects/", `
					BASE &lt;http://localhost:8083/apps/my-app/>
					PREFIX ldp: &lt;http://www.w3.org/ns/ldp#>
					SELECT ?projectName ?projectStart
					WHERE {
						&lt;projects/> ldp:contains ?everyProject .
					    ?everyProject &lt;vocabulary/#name> ?projectName ;
					                  &lt;vocabulary/#startDate> ?projectStart
					}
					ORDER BY DESC( ?projectStart )
					LIMIT 10
				` )
					.then( ( [ result, response ]:[ SPARQL.SELECTResults.Class, HTTP.Response.Class ] ) => {
						return result
							.bindings
							.map( binding => ( {
								name: binding[ "projectName" ],
								startDate: binding[ "projectStart" ],
							} )
							;
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.executeSELECTQuery( "projects/", `
					BASE &lt;http://localhost:8083/apps/my-app/>
					PREFIX ldp: &lt;http://www.w3.org/ns/ldp#>
					SELECT ?projectName ?projectStart
					WHERE {
						&lt;projects/> ldp:contains ?everyProject .
					    ?everyProject &lt;vocabulary/#name> ?projectName ;
					                  &lt;vocabulary/#startDate> ?projectStart
					}
					ORDER BY DESC( ?projectStart )
					LIMIT 10
				` )
					.then( ( [ result, response ] ) => {
						return result
							.bindings
							.map( binding => ( {
								name: binding[ "projectName" ],
								startDate: binding[ "projectStart" ],
							} )
							;
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.executeSELECTQuery( "projects/", "" +
					"BASE &lt;http://localhost:8083/apps/my-app/>" +
					"PREFIX ldp: &lt;http://www.w3.org/ns/ldp#>" +
					"SELECT ?projectName ?projectStart" +
					"WHERE {" +
					"   &lt;projects/> ldp:contains ?everyProject ." +
					"   ?everyProject &lt;vocabulary/#name> ?projectName ;" +
					"                 &lt;vocabulary/#startDate> ?projectStart" +
					"}" +
					"ORDER BY DESC( ?projectStart )" +
					"LIMIT 10"
				)
					.then( function( [ result, response ] ) {
						return result
							.bindings
							.map( function( binding ) {
								return {
									name: binding[ "projectName" ],
									startDate: binding[ "projectStart" ],
								};
							} )
							;
					} )
					;
			</code></pre>
			</tab>
		</tabs>

	</section>

	<section class="mainContent-subSection">
		<h3>ASK Queries</h3>
		<ul>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeASKQuery">executeASKQuery</a>( documentURI:string, askQuery: string )</code></li>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeRawASKQuery">executeRawASKQuery</a>( documentURI:string, askQuery: string )</code></li>
		</ul>

		<p>
			The fist option, as the SELECT does, offers you an easier response with only the resulted boolean of the query.
			Instead, the second one will return the JSON object as described in the <a href="https://www.w3.org/TR/2013/REC-sparql11-results-json-20130321/#ask-result-form">specification</a>:
			<code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-SPARQL-RawResults-Class">Carbon.SPARQL.RawResults.Class</a></code>
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import * as HTTP from "carbonldp/HTTP";

				let appContext:App.Context;
				// ... get context

				appContext.documents.executeASKQuery( "projects/project-01/", `
					BASE        &lt;http://localhost:8083/apps/my-app/>
					ASK {
					    &lt;projects/project-01/> &lt;vocabulary/#name> "Project X" ;
											   &lt;vocabulary/#startDate> "2017/02/19"
					}
				` )
					.then( ( [ result, response ]:[ boolean, HTTP.Response.Class ] ) => {
						// result will be `true`
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.executeASKQuery( "projects/project-01/", `
					BASE        &lt;http://localhost:8083/apps/my-app/>
					ASK {
					    &lt;projects/project-01/> &lt;vocabulary/#name> "Project X" ;
											   &lt;vocabulary/#startDate> "2017/02/19"
					}
				` )
					.then( ( [ result, response ] ) => {
						// result will be `true`
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.executeASKQuery( "projects/project-01/", "" +
					"BASE        &lt;http://localhost:8083/apps/my-app/>" +
					"ASK {" +
					"    &lt;projects/project-01/> &lt;vocabulary/#name> \"Project X\" ;" +
					"                           &lt;vocabulary/#startDate> \"2017/02/19\"" +
					"}" +
				)
					.then( function( [ result, response ] ) {
						// result will be `true`
					} )
					;
			</code></pre>
			</tab>
		</tabs>
	</section>

	<section class="mainContent-subSection">
		<h3>CONSTRUCT Queries</h3>
		<ul>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeRawCONSTRUCTQuery">executeRawCONSTRUCTQuery</a>( documentURI:string, constructQuery:string )</code></li>
		</ul>

		<p>
			The SDK only supports making the CONSTRUCT query and give to you the raw string retrieved by the server. This string
			is in a JSON-LD format, so you will have to process and parse it to your needs.
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import * as HTTP from "carbonldp/HTTP";

				let appContext:App.Context;
				// ... get context

				appContext.documents.executeRawCONSTRUCTQuery( "projects/project-01/", `
					BASE        &lt;http://localhost:8083/apps/my-app/>
					PREFIX schema:  &lt;https://schema.org/>
					CONSTRUCT   {
						&lt;projects/project-01/> schema:name ?projectName ;
											   schema:startDate ?projectStart
					}
					WHERE {
					    &lt;projects/project-01/> &lt;vocabulary/#name> ?projectName ;
											   &lt;vocabulary/#startDate> ?projectStart
					}
				` )
					.then( ( [ result, response ]:[ string, HTTP.Response.Class ] ) => {
						// ... process the result JSON-LD string
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.executeRawCONSTRUCTQuery( "projects/project-01/", `
					BASE        &lt;http://localhost:8083/apps/my-app/>
					PREFIX schema:  &lt;https://schema.org/>
					CONSTRUCT   {
						&lt;projects/project-01/> schema:name ?projectName ;
											   schema:startDate ?projectStart
					}
					WHERE {
					    &lt;projects/project-01/> &lt;vocabulary/#name> ?projectName ;
											   &lt;vocabulary/#startDate> ?projectStart
					}
				` )
					.then( ( [ result, response ] ) => {
						// ... process the result JSON-LD string
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.executeRawCONSTRUCTQuery( "projects/project-01/", "" +
					"BASE        &lt;http://localhost:8083/apps/my-app/>" +
					"PREFIX schema:  &lt;https://schema.org/>" +
					"CONSTRUCT   {" +
					"	&lt;projects/project-01/> schema:name ?projectName ;" +
					"                          schema:startDate ?projectStart" +
					"}" +
					"WHERE {" +
					"    &lt;projects/project-01/> &lt;vocabulary/#name> ?projectName ;" +
					"                           &lt;vocabulary/#startDate> ?projectStart" +
					"}"
				)
					.then( function( [ result, response ] ) {
						// ... process the result JSON-LD string
					} )
					;
			</code></pre>
			</tab>
		</tabs>

		<p>
			In this example we create an Document with only the name and start date of the project, but the difference
			is that we rename the properties to a well defined the vocabulary: <code>https://schema.org/</code>:
		</p>
		<pre><code class="javascript">
			// Representation of the string returned
			{
				"id": "http://localhost:8083/apps/my-app/projects/project-01/",

				// Properties
				"https://schema.org/name": "Project X",
				"https://schema.org/startDate": "2017/02/19"
			}
		</code></pre>
	</section>

	<section class="mainContent-subSection">
		<h3>DESCRIBE Queries</h3>
		<ul>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeRawDESCRIBEQuery">executeRawDESCRIBEQuery</a>( documentURI:string, describeQuery: string )</code></li>
		</ul>

		<p>
			Same as the CONSTRUCT queries, the SDK only returns the RAW JSON-LDP string as the response of this services.
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import * as HTTP from "carbonldp/HTTP";

				let appContext:App.Context;
				// ... get context

				appContext.documents.executeRawDESCRIBEQuery( "projects/project-01/", `
					BASE     &lt;http://localhost:8083/apps/my-app/>
					DESCRIBE &lt;projects/project-01/>
				` )
					.then( ( [ result, response ]:[ string, HTTP.Response.Class ] ) => {
						// ... process the result JSON-LD string
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.executeRawDESCRIBEQuery( "projects/project-01/", `
					BASE     &lt;http://localhost:8083/apps/my-app/>
					DESCRIBE &lt;projects/project-01/>
				` )
					.then( ( [ result, response ] ) => {
						// ... process the result JSON-LD string
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.executeRawDESCRIBEQuery( "projects/project-01/", "" +
					"BASE     &lt;http://localhost:8083/apps/my-app/>" +
					"DESCRIBE &lt;projects/project-01/>"
				)
					.then( function( [ result, response ] ) {
						// ... process the result JSON-LD string
					} )
					;
			</code></pre>
			</tab>
		</tabs>
	</section>

	<section class="mainContent-subSection">
		<h3>UPDATE</h3>
		<ul>
			<li><code><a href="https://carbonldp.github.io/carbonldp-js-sdk/#Carbon-Documents-Class-executeUPDATE">executeUPDATE</a>( documentURI:string, update: string )</code></li>
		</ul>

		<p>
			An SPARQL UPDATE doesn't return any result data, thus it's not exactly a query
			and that's the reason of only one method if this service in the SDK.
		</p>

		<tabs>
			<tab title="TypeScript">
			<pre><code class="typescript">
				import * as App from "carbonldp/App";
				import * as HTTP from "carbonldp/HTTP";

				let appContext:App.Context;
				// ... get context

				appContext.documents.executeUPDATE( "projects/project-01/", `
					BASE     &lt;http://localhost:8083/apps/my-app/>
					DELETE {
						&lt;projects/project-01/> &lt;vocabulary/#name> "Project X"
					}
					INSERT {
						&lt;projects/project-01/> &lt;vocabulary/#name> "My new awesome name"
					}
					WHERE {
						&lt;projects/project-01/> &lt;vocabulary/#name> "Project X"
					}
				` )
					.then( ( response:HTTP.Response.Class ) => {
						// ... Update finished
					} )
					;
			</code></pre>
			</tab>
			<tab title="JavaScript ES2015">
			<pre><code class="javascript">
				let appContext;
				// ... get context

				appContext.documents.executeUPDATE( "projects/project-01/", `
					BASE     &lt;http://localhost:8083/apps/my-app/>
					DELETE {
						&lt;projects/project-01/> &lt;vocabulary/#name> "Project X"
					}
					INSERT {
						&lt;projects/project-01/> &lt;vocabulary/#name> "My new awesome name"
					}
					WHERE {
						&lt;projects/project-01/> &lt;vocabulary/#name> "Project X"
					}
				` )
					.then( response  => {
						// ... Update finished
					} )
					;
				</code></pre>
			</tab>
			<tab title="JavaScript ES5">
			<pre><code class="javascript">
				var appContext;
				// ... get context

				appContext.documents.executeUPDATE( "projects/project-01/", "" +
					"BASE     &lt;http://localhost:8083/apps/my-app/>" +
					"DELETE {" +
					"	&lt;projects/project-01/> &lt;vocabulary/#name> \"Project X\"" +
					"}" +
					"INSERT {" +
					"	&lt;projects/project-01/> &lt;vocabulary/#name> \"My new awesome name\"" +
					"}" +
					"WHERE {" +
					"	&lt;projects/project-01/> &lt;vocabulary/#name> \"Project X\"" +
					"}"
				)
					.then( function( response ) {
						// ... Update finished
					} )
					;
			</code></pre>
			</tab>
		</tabs>
	</section>

</section>

<div class="documentation-steps ui fluid steps">
	<a class="step" href="../files">
		<i class="arrow left icon"></i>
		<div class="content">
			<div class="title">Previous</div>
			<div class="description">Files</div>
		</div>
	</a>
	<div class="active step">
		<!--<i class="payment icon"></i>-->
		<div class="content">
			<div class="title">Querying</div>
		</div>
	</div>
	<a class="step" href="../authentication">
		<i class="arrow right icon"></i>
		<div class="content">
			<div class="title">Next</div>
			<div class="description">Authentication</div>
		</div>
	</a>
</div>
